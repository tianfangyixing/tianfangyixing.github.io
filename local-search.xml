<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>20. 欧拉函数</title>
    <link href="/2024/01/18/AcwingBasicCourse/math3/"/>
    <url>/2024/01/18/AcwingBasicCourse/math3/</url>
    
    <content type="html"><![CDATA[<h2 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h2><p>欧拉函数，是1到n与它互质的数的个数，记作<script type="math/tex">\varphi(n)</script>。例如<script type="math/tex">\varphi(9) = 6</script> 因为<script type="math/tex">1,2,4,5,7,8</script>与<script type="math/tex">9</script>互质。</p><h3 id="性质1-varphi-p-k-p-k-p-k-1"><a href="#性质1-varphi-p-k-p-k-p-k-1" class="headerlink" title="性质1 \varphi(p^k)=p^k-p^{k-1}"></a>性质1 <script type="math/tex">\varphi(p^k)=p^k-p^{k-1}</script></h3><p>对于质数<script type="math/tex">p</script>，<script type="math/tex">p^k</script>中不与它互质的数有<script type="math/tex">p,2p,3p,4p,..,p^{k-1} \times p</script>，也就是<script type="math/tex">p^{k-1}</script>个，又<script type="math/tex">1~p^k</script>有p^k个数，那么<script type="math/tex">\varphi(p^k)=p^k-p^{k-1}</script></p><h3 id="性质2-varphi-p-a-q-b-varphi-p-a-varphi-q-b"><a href="#性质2-varphi-p-a-q-b-varphi-p-a-varphi-q-b" class="headerlink" title="性质2 \varphi(p^a q^b) = \varphi(p^a)\varphi(q^b)"></a>性质2 <script type="math/tex">\varphi(p^a q^b) = \varphi(p^a)\varphi(q^b)</script></h3><p>对于质数<script type="math/tex">p</script>和<script type="math/tex">q</script>，从<script type="math/tex">1</script>到<script type="math/tex">p^a q^b</script>，可以分为四种数，一种是<script type="math/tex">p</script>的倍数，一种是<script type="math/tex">q</script>的倍数，一种是<script type="math/tex">pq</script>倍数，一种是与<script type="math/tex">p^a q^b</script>互质的数，显然<script type="math/tex">p</script>的倍数与<script type="math/tex">q</script>的倍数<br>的部分有交叉，交叉部分恰好为pq倍数。设x的倍数的数量记作<script type="math/tex">m(x)</script><br>枚举<script type="math/tex">p,2p,3p,...,(p^{a-1}q^b) \times p</script>，<script type="math/tex">m(p)=p^{a-1}q^b</script><br>枚举<script type="math/tex">q,2q,3q,...,(p^a q^{b-1}) \times q</script>，<script type="math/tex">m(q)=p^a q^{b-1}</script><br>枚举<script type="math/tex">pq,2pq,3pq,...,(p^{a-1}b^{b-1})\times pq</script>，<script type="math/tex">m(pq)=p^{a-1} q^{b-1}</script><br>而与<script type="math/tex">p^a q^b</script>互质的数，为<script type="math/tex">\varphi(p^a q^b)</script><br>四者必然满足 <script type="math/tex">n = p^a q^b = m(p) + m(q) - m(pq) + \varphi(p^a q^b)</script><br>对其进行变式</p><script type="math/tex; mode=display">\begin{eqnarray}    \label{eq}\varphi{(p^a q^b)}&=&n - m(p) - m(q) + m(pq)\nonumber    \\&=&p^a q^b - p^{a-1}q^b - p^a q^{b-1} + p^{a-1} q^{b-1} \nonumber    \\&=&(p^{a-1}-1)(q^{b-1}-1) \nonumber    \\&=&\varphi(p^a)\varphi(q^b)\end{eqnarray}</script><h3 id="程序求解欧拉函数"><a href="#程序求解欧拉函数" class="headerlink" title="程序求解欧拉函数"></a>程序求解欧拉函数</h3><p>求解<script type="math/tex">\varphi(n)</script>，实际上可以将n质因数分解，<script type="math/tex">n = p_{1}^{a_{1}} \times  p_{2}^{a_{2}} \times... \times  p_{n}^{a_{n}}</script>，</p><script type="math/tex; mode=display">\begin{equation*}  \begin{aligned}    \varphi(n) &= \varphi({p_{1}^{a_{1}}  p_{2}^{a_{2}} ...   p_{n}^{a_{n}}}) \\         &= \varphi{(p_{1}^{a_{1}})}  \varphi{(p_{2}^{a_{2}})}  ...  \varphi{(p_{n}^{a_{n}})} \\         &= (p^{a_{1}} - p^{a_{1}-1})(p^{a_{2}} - p^{a_{2}-1}) (p^{a_{n}} - p^{a_{n}-1}) \\         &= p_{1}^{a_{1}} p_{2}^{a_{2}} ...   p_{n}^{a_{n}} \times(1-\frac{1}{p_{1}})(1-\frac{1}{p_{2}})...(1-\frac{n}{p_{n}})) \\         &= n \times(1-\frac{1}{p_{1}})(1-\frac{1}{p_{2}})...(1-\frac{n}{p_{n}}))  \\  \end{aligned}\end{equation*}</script><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">ull <span class="hljs-title">EulerTotient</span><span class="hljs-params">(ull n)</span> </span>&#123;<br>    ull result = n;<br>    unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; primes;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; (ull)i &lt;= n / i; i++) &#123;<br>        <span class="hljs-keyword">if</span>(n % i == <span class="hljs-number">0</span>) &#123;<br>            ull times = <span class="hljs-number">0</span>;<br>            <br>            <span class="hljs-keyword">while</span>(n % i == <span class="hljs-number">0</span>) &#123;<br>                n /= i;<br>                times++;<br>            &#125;<br>            <br>            primes[i] = times;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span>(n != <span class="hljs-number">1</span>) &#123;<br>        primes[n] = <span class="hljs-number">1</span>;<br>    &#125;<br>    <br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> prime : primes) &#123;<br>        result = (result * prime.first - result) / prime.first;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="筛法求欧拉函数"><a href="#筛法求欧拉函数" class="headerlink" title="筛法求欧拉函数"></a>筛法求欧拉函数</h2><p>运用欧拉筛法去求<script type="math/tex">\sum_{i=1}^{n}\varphi(i)</script><br>对于质数p，<script type="math/tex">\varphi(p) = p - 1</script><br>对于用最小质因子p标记的<script type="math/tex">p * i</script>，它的欧拉函数求解有两种情况<br>一种是p和i互质,<script type="math/tex">\varphi(p * i) = \varphi(p) \times \varphi(i)</script><br>一种是p和i不互质，说明i包含p的所有质因子， 因此有<script type="math/tex">\varphi(p * i) = i \times \varphi(p)</script><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">ull <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<br>    vector&lt;<span class="hljs-type">int</span>&gt; primes;<br>    <span class="hljs-type">int</span> totient[N];<br>    <span class="hljs-type">bool</span> isNotPrime[N];<br>    ull total = <span class="hljs-number">0</span>;<br>    <br>    totient[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">if</span>(!isNotPrime[i]) &#123;<br>            primes.<span class="hljs-built_in">push_back</span>(i);<br>            totient[i] = i - <span class="hljs-number">1</span>; <br>        &#125;<br>        <br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; primes.<span class="hljs-built_in">size</span>() &amp;&amp; primes[j] * i &lt;= n; j++) &#123;<br>            isNotPrime[primes[j] * i] = <span class="hljs-literal">true</span>;<br>            <br>            <span class="hljs-keyword">if</span>(i % primes[j] == <span class="hljs-number">0</span>) &#123;<br>                totient[primes[j] * i] = primes[j] * totient[i];<br>                <span class="hljs-keyword">break</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                totient[primes[j] * i] = totient[i] * totient[primes[j]];<br>            &#125;<br>        &#125; <br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        total += totient[i];<br>    &#125;<br>    <br>    <br>    <span class="hljs-keyword">return</span> total;<br>    <br>&#125;<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>19. 约数</title>
    <link href="/2024/01/18/AcwingBasicCourse/math2/"/>
    <url>/2024/01/18/AcwingBasicCourse/math2/</url>
    
    <content type="html"><![CDATA[<h2 id="求约数"><a href="#求约数" class="headerlink" title="求约数"></a>求约数</h2><p>求正整数a的所有约数，可以从1到a一个个遍历，看是不是它的因子。但前面我们已知道出现一个因子<script type="math/tex">i</script>，必然存在对应的另外一个因子<script type="math/tex">\frac{a}{i}</script>，易得只要遍历1到<script type="math/tex">\sqrt{a}</script>，就相当于遍历1到<script type="math/tex">a</script>。</p><p>同时需要注意的是，如果到<script type="math/tex">\sqrt{a}</script>是它的因子，要规定只push一次<br>代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">getDivisors</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; nums;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= a / i; i++) &#123;<br>        <span class="hljs-keyword">if</span>(a % i == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span>(i != a / i) &#123;<br>                nums.<span class="hljs-built_in">push_back</span>(i);<br>                nums.<span class="hljs-built_in">push_back</span>(a / i);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                nums.<span class="hljs-built_in">push_back</span>(i);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> nums;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="求约数个数"><a href="#求约数个数" class="headerlink" title="求约数个数"></a>求约数个数</h2><p>要求a的约数的个数，看起来好像可以求约数然后再取vector的size就可以了。但是一旦数大了，那么做效率低。<br>实际上，我们可以对a进行质因数分解 </p><script type="math/tex; mode=display">a = p_{1}^{a_{1}} \times  p_{2}^{a_{2}} \times  p_{3}^{a_{3}} \times  p_{4}^{a_{4}} \times... \times  p_{n}^{a_{n}}</script><p>注意到a的约数只是<script type="math/tex">p_{1}</script>到<script type="math/tex">p_{n}</script>的幂表示，只是它们的组合，可以用分步计数原理进行求解，得到</p><script type="math/tex; mode=display">count = (a_{1} + 1) \times (a_{2} + 1) \times (a_{3} + 1) \times ...\times(a_{n} + 1)</script><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getDivisorCount</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> </span>&#123;<br>    unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; primes = <span class="hljs-built_in">divide</span>(a);<br>    <span class="hljs-type">int</span> count = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> prime : primes) &#123;<br>        count *= (prime.second + <span class="hljs-number">1</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="求约数的和"><a href="#求约数的和" class="headerlink" title="求约数的和"></a>求约数的和</h2><p>要求a的约数的和，同样的，我们可以对a进行质因数分解。</p><script type="math/tex; mode=display">a = p_{1}^{a_{1}} \times  p_{2}^{a_{2}} \times  p_{3}^{a_{3}} \times  p_{4}^{a_{4}} \times... \times  p_{n}^{a_{n}}</script><p>注意到a的约数只是<script type="math/tex">p_{1}</script>到<script type="math/tex">p_{n}</script>的组合，所以a的约数的和为</p><script type="math/tex; mode=display">sum = (p_{1}^{0} + p_{1}^{1} + p_{1}^{2} + ... + p_{1}^{a_{1}}) \times (p_{1}^{0} + p_{2}^{1} + p_{2}^{2} + ... + p_{2}^{a_{2}}) \times ... \times (p_{n}^{0} + p_{n}^{1} + p_{n}^{2} + p_{n}^{a_{n}})</script><p>代码为<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getDivisorSum</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> </span>&#123;<br>    ull sum = <span class="hljs-number">1</span>;<br>    unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; primes = <span class="hljs-built_in">divide</span>(a);<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> prime : primes) &#123;<br>        <span class="hljs-type">int</span> subSum = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> t = <span class="hljs-number">1</span>;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= prime.second; i++) &#123;<br>            subSum += t;<br>            t *= prime.first;<br>        &#125;<br>        <br>        sum *= subSum;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="求最大公约数"><a href="#求最大公约数" class="headerlink" title="求最大公约数"></a>求最大公约数</h2><p>求最大公约数，即求两个数的最大公因子。我们可以用数学上的辗转相除法来解决。辗转相除法基于如下原理：两个整数的最大公约数等于其中较小的数和两数相除余数的最大公约数，数学语言描述：</p><script type="math/tex; mode=display">若a > b, 则gcd(a, b)=gcd(b,a \; mod \; b)</script><p>证明如下：<br>设<script type="math/tex">d</script>是<script type="math/tex">a</script>和<script type="math/tex">b</script>的最小公约数，<script type="math/tex">c = a \; mod \; b</script>，即<script type="math/tex">a \mid d</script>并且<script type="math/tex">b \mid d</script>又<script type="math/tex">c = \frac{a-kb}{d} = \frac{a}{d}-\frac{kb}{d}</script>，则必然满足<script type="math/tex">c \mid d</script><br>我们不断将函数第二项递减，递减到0，此时的第一项就是最大公约数<br>例如</p><script type="math/tex; mode=display">gcd(12,9)=gcd(9,3)=gcd(3,0)</script><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gcd_version1</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(a &lt; b) &#123;<br>        <span class="hljs-built_in">swap</span>(a, b);<br>    &#125;<br>    <br>    <span class="hljs-keyword">while</span>(b != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">int</span> temp = a % b;<br>        a = b;<br>        b = temp; <br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> a;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gcd_version2</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br><span class="hljs-keyword">return</span> b ? <span class="hljs-built_in">gcd</span>(b, a % b) : a;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>18. 质数</title>
    <link href="/2024/01/17/AcwingBasicCourse/math1/"/>
    <url>/2024/01/17/AcwingBasicCourse/math1/</url>
    
    <content type="html"><![CDATA[<p>质数是指只有2个因子并且大于或等于2的数</p><h2 id="判断一个数是否为质数"><a href="#判断一个数是否为质数" class="headerlink" title="判断一个数是否为质数"></a>判断一个数是否为质数</h2><h3 id="暴力做法"><a href="#暴力做法" class="headerlink" title="暴力做法"></a>暴力做法</h3><p>遍历2到x-1的每一个数，看这些数是否是它的因子，即判断是否能够整除，如果碰到能整除的数，则不是质数。如果都不能整除，则是质数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPrime</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(x == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; x; i++) &#123;<br>        <span class="hljs-keyword">if</span>(x % i == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>但实际上我们并不需要遍历2到x-1的每一个数。实际上如果x存在一个因子 <script type="math/tex">p</script>，则必然存在另外一个因子 <script type="math/tex">\frac{x}{p}</script> ，这两个因子，一个小于等于<script type="math/tex">\sqrt{x}</script>，一个大于等于<script type="math/tex">\sqrt{x}</script>，如果在<script type="math/tex">\sqrt{x}</script>到<script type="math/tex">x-1</script>有因子，则必然在<script type="math/tex">2</script>到<script type="math/tex">\sqrt{x}</script>有因子，二者是充要的。也就是说判断<script type="math/tex">2</script>到<script type="math/tex">\sqrt{x}</script>有因子，也就判断了<script type="math/tex">\sqrt{x}</script>到<script type="math/tex">x-1</script>有因子，也就判断了<script type="math/tex">2</script>到<script type="math/tex">x-1</script>是否有因子。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPrime</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(x == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= <span class="hljs-built_in">sqrt</span>(x); i++) &#123;<br>        <span class="hljs-keyword">if</span>(x % i == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于 <script type="math/tex">i \le \sqrt{x}</script> 条件可以优化为<script type="math/tex">i \mul i \le x</script>，又<script type="math/tex">i \mul i</script>可能会溢出，改写成 <script type="math/tex">i \le x * i</script></p><h2 id="质因数分解"><a href="#质因数分解" class="headerlink" title="质因数分解"></a>质因数分解</h2><p>算术基本定理：每个大于1的自然数，要么本身就是质数，要么可以写为2个或以上的质数的积。这告诉我们任意一个合数都可以被质因数分解。例如<script type="math/tex">6936</script>的分解</p><script type="math/tex; mode=display">6936 = 2^3 \times 3 \times 17 ^ 2</script><h3 id="暴力做法-1"><a href="#暴力做法-1" class="headerlink" title="暴力做法"></a>暴力做法</h3><p>如何用程序实现质因数分解呢？暴力做法是从小到大遍历2到x的质数，看是否能整除，能整除的话，算次数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">divide</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= num; i++) &#123;<br>        <span class="hljs-keyword">if</span>(num % i == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">int</span> times = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span>(num % i == <span class="hljs-number">0</span>) &#123;<br>                num /= i;<br>                times++;<br>            &#125;<br>            cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; times &lt;&lt; endl;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中代码i可能为合数，但必然不会执行if内的语句。假设i是合数，而且<script type="math/tex">num \% i \neq 0</script>，即i是num的因子，i必然存在大于等于2而且小于i的因子，也是num的因子。而在前面的循环中，已经整除到不能再整除，即不可能存在比i小的数，是num的因子。故矛盾，则执行if的语句的必然是质数。</p><h3 id="优化-1"><a href="#优化-1" class="headerlink" title="优化"></a>优化</h3><p>实际上我们不用遍历2到x的质数，只需要遍历2到<script type="math/tex">\sqrt{x}</script>的质数。因为因子只能小于等于<script type="math/tex">\sqrt{x}</script>，跟前面一样循环条件可以等价为<script type="math/tex">i \le num/i</script></p><p>注意：最后要判断有无除尽，如果为质数，则结果出错</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">divide</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= num / i; i++) &#123;<br>        <span class="hljs-keyword">if</span>(num % i == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">int</span> times = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span>(num % i == <span class="hljs-number">0</span>) &#123;<br>                num /= i;<br>                times++;<br>            &#125;<br>            cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; times &lt;&lt; endl;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span>(num != <span class="hljs-number">1</span>) &#123;<br>        cout &lt;&lt; num &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; <span class="hljs-number">1</span> &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="筛质数"><a href="#筛质数" class="headerlink" title="筛质数"></a>筛质数</h2><p>筛质数，即找出从2到n中所有的质数</p><h3 id="普通筛法"><a href="#普通筛法" class="headerlink" title="普通筛法"></a>普通筛法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">getPrimes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; primes;<br>    <span class="hljs-type">bool</span> isNotPrimes[<span class="hljs-number">20000100</span>];<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">if</span>(!isNotPrimes[i]) &#123;<br>            primes.<span class="hljs-built_in">push_back</span>(i);<br>        &#125;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i; j &lt;= n; j += i) &#123;<br>            isNotPrimes[j] = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> primes;<br>&#125;<br></code></pre></td></tr></table></figure><p>在普通筛法代码中，我们如何判断某个数是质数还是质数呢？我们一直在维护一个从2到i的是否为质数的表。假如有标记，则是合数。那么我们如何进行维护的呢？对于每一个数，我们对它的倍数进行标记。显然，遍历到i时，i是合数的话，那么必然存在比它小的因子（大于等于2），已经在前面标记好True。对于质数，没有标记，则是判定为质数。</p><h3 id="欧拉筛法"><a href="#欧拉筛法" class="headerlink" title="欧拉筛法"></a>欧拉筛法</h3><p>注意到如果i是合数的话，没必要对i的倍数进行标记，因为它必然存在一个质因子，质因子的倍数必然包含合数的倍数，所以质因子标记必然包含了合数的标记，所以只要质数进行标记操作即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">getPrimes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; primes;<br>    <span class="hljs-type">bool</span> isNotPrimes[<span class="hljs-number">20000100</span>];<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">if</span>(!isNotPrimes[i]) &#123;<br>            primes.<span class="hljs-built_in">push_back</span>(i);<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i; j &lt;= n; j += i) &#123;<br>                 isNotPrimes[j] = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> primes;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是实际上还有会有重复标记，注意到，2和3都是质数，2和3都会标记6。有没有一种办法，不产生重复标记，如果要标记x，只用x的最小质因子去标记。先贴出代码，后讲解</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">getPrimes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; primes;<br>    <span class="hljs-type">bool</span> isNotPrimes[<span class="hljs-number">20000100</span>];<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">if</span>(!isNotPrimes[i]) &#123;<br>            primes.<span class="hljs-built_in">push_back</span>(i);<br>        &#125;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; primes.<span class="hljs-built_in">size</span>() &amp;&amp; primes[j] * i &lt;= n; j++) &#123;<br>            isNotPrimes[primes[j] * i] = <span class="hljs-literal">true</span>;<br>            <br>            <span class="hljs-keyword">if</span>(i % primes[j] == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> primes;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先讲它是不是被最小质因数给标记掉的，我们是标记<script type="math/tex">primes[j] * i</script>，标记到<script type="math/tex">primes[j] * i</script>，那么要不要标记下一个 <script type="math/tex">primes[j+1] * i</script>，要看<script type="math/tex">primes[j+1] * i</script>的最小质因子是不是<script type="math/tex">primes[j+1]</script>。由于<script type="math/tex">primes[j+1] * i</script>的质因子包含了<script type="math/tex">primes[j+1]</script>和<script type="math/tex">i</script>的质因子，要判断<script type="math/tex">primes[j+1] * i</script>的最小质因子，只需要看<script type="math/tex">i</script>的最小质因子与<script type="math/tex">prime[j+1]</script>的大小关系。如果i能被primes[j]整除，说明i的最小质因子为primes[j]，比primes[j+1]小，则不能进行下一步标记，要退出循环。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>17. 堆</title>
    <link href="/2024/01/07/AcwingBasicCourse/17/"/>
    <url>/2024/01/07/AcwingBasicCourse/17/</url>
    
    <content type="html"><![CDATA[<p>堆是一个完全二叉树。小根堆是父节点小于子节点的堆，显然，根节点为最小值。大根堆是父节点大于子节点的堆，显然，根节点为最大值。</p><h3 id="子节点与父节点的下标关系"><a href="#子节点与父节点的下标关系" class="headerlink" title="子节点与父节点的下标关系"></a><strong>子节点与父节点的下标关系</strong></h3><p>leftChild = parent * 2 + 1 \\ rightChild = parent * 2 + 2 \\ parent = (child - 1) \div 2</p><p>注意：除法是向下取整</p><h3 id="上浮-amp-下沉"><a href="#上浮-amp-下沉" class="headerlink" title="上浮&amp;下沉"></a><strong>上浮&amp;下沉</strong></h3><p>在堆中，有两个重要操作，上浮和下沉，这里我们以大根堆为例。</p><p><strong>1.上浮</strong></p><p>不断比较该节点与父节点，若该节点较大则交换，并与更上一层的节点进行该操作，直至该节点较小或已经到达最顶部为止</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">up</span><span class="hljs-params">(<span class="hljs-type">int</span> * numbers, <span class="hljs-type">int</span> i)</span> </span>&#123;<br>    <span class="hljs-type">int</span> parent = (i - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span> child = i;<br><br>    <span class="hljs-keyword">while</span>(child &gt; <span class="hljs-number">0</span> &amp;&amp; numbers[parent] &gt; numbers[child]) &#123;<br>        <span class="hljs-built_in">swap</span>(numbers[parent], numbers[child]);<br>        child = parent;<br>        parent = (parent - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>2.下沉</strong></p><p>不断比较该节点与子节点，若该节点较小则交换，并与更下一层的节点进行该操作，直至该节点较大或已经到达最底部为止</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">down</span><span class="hljs-params">(<span class="hljs-type">int</span> * numbers, <span class="hljs-type">int</span> size, <span class="hljs-type">int</span> i)</span> </span>&#123;<br>    <span class="hljs-type">int</span> parent = i;<br>    <span class="hljs-type">int</span> child = i * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">while</span>(child &lt; size) &#123;<br>        <span class="hljs-keyword">if</span>( (child + <span class="hljs-number">1</span>) &lt; size &amp;&amp; numbers[child + <span class="hljs-number">1</span>] &lt; numbers[child]) &#123;<br>            child++;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(numbers[child] &lt; numbers[parent]) &#123;<br>            <span class="hljs-built_in">swap</span>(numbers[child], numbers[parent]);<br>            parent = child;<br>            child = child * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="构造小根堆或大根堆"><a href="#构造小根堆或大根堆" class="headerlink" title="构造小根堆或大根堆"></a><strong>构造小根堆或大根堆</strong></h3><p>将一个序列处理成小根堆和大根堆，是堆排序的第一步。这里我们还是以大根堆为例。</p><ol><li><strong>自顶向下构造</strong></li></ol><p>最开始，堆只包含第一个元素。然后不断加入新的元素，并上浮加入的元素，维护它是一个大根堆。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>    <span class="hljs-built_in">up</span>(nums, i);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>2. 自底向顶构造</strong></p><p>一开始堆只包含一个非叶节点和它的叶节点，使用下沉操作，使得它成为大根堆。不断加入非叶节点，并下沉它，维护它是大根堆。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = size/<span class="hljs-number">2</span>- <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>    <span class="hljs-built_in">down</span>(nums, size, i);<br>&#125;<br></code></pre></td></tr></table></figure><p>两者都能很好实现大根堆的构造，但是自底向顶比自顶向底快很多。</p><h3 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h3><p>将元素放到最后一个位置，将其上浮</p><h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><p>将该元素与最后一个元素交换位置，将最后一个元素上浮和下沉</p><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>堆排序的时间复杂度是 O(logN) ，其步骤分为三步</p><p>1. 将序列构造称大根堆</p><p>2. 将根节点与堆的最后一个元素交换</p><p>3. 将此时的根节点下沉，此时形成一个大小减1的新的大根堆</p><p>不断重复（2）（3）步，直至堆只有1个元素为止。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>16. 并查集</title>
    <link href="/2024/01/07/AcwingBasicCourse/16/"/>
    <url>/2024/01/07/AcwingBasicCourse/16/</url>
    
    <content type="html"><![CDATA[<p>并查集是管理元素所属集合的数据结构，它的重要操作有两个，一是合并操作，二是查询所属集合的操作。</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>初始化时，所有的元素都是互不关联的，每个节点都是一颗树，树中只有它自己一个节点。其中，用数组存储父节点或祖先节的点下标地址。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        parent[i] = i;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="区分所属集合"><a href="#区分所属集合" class="headerlink" title="区分所属集合"></a>区分所属集合</h3><p>在并查集，如何看两个元素是否所属同一个集合呢？用元素所属树的根节点来区分。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findAncestorNode</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> </span>&#123;<br>    <span class="hljs-type">int</span> ancestorNode = a;<br>    <br>    <span class="hljs-keyword">while</span>(parent[ancestorNode] != ancestorNode) &#123;<br>        ancestorNode = parent[ancestorNode];<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> ancestorNode;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isConnected</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">findAncestorNode</span>(a) == <span class="hljs-built_in">findAncestorNode</span>(b);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="合并集合"><a href="#合并集合" class="headerlink" title="合并集合"></a><strong>合并集合</strong></h2><p>我们合并两个元素所在的集合，是将一个数的祖先节点插入到另外一个数的祖先节点下面。因此我们有代码</p><p>{\color{salmon}{注意: 要检查是否所属同一个集合}}</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">findAncestorNode</span>(a) == <span class="hljs-built_in">findAncestorNode</span>(b)) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    parent[<span class="hljs-built_in">findAncestorNode</span>(a)] = <span class="hljs-built_in">findAncestorNode</span>(b);<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h2><p>当我们在不断地合并集合时，往往会出现树的高度很大，形成一个链或者接近一条链。这就导致查找时间几乎接近链表的查找时间。怎么办呢？</p><p>我们可以在查找a元素的祖先节点时，进行路径压缩：令a到祖先节点的路径上所有的节点都指向祖先节点。这样在搜索的过程中，就降低了树的高度，降低了查找时间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findAncestorNode</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(parent[a] != a) &#123;<br>        parent[a] = <span class="hljs-built_in">findAncestorNode</span>(disjointSet[a]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> parent[a];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="按秩合并"><a href="#按秩合并" class="headerlink" title="按秩合并"></a>按秩合并</h2><p>同时，我们还可以在合并的过程中，将树的高度小的接到树的高度大的下面，以减少树的高度的增加程度。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>   <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        parent[i] = i;<br>        height[i] = <span class="hljs-number">1</span>;<br>   &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    <span class="hljs-type">int</span> aAncestorNode = <span class="hljs-built_in">findAncestorNode</span>(a);<br>    <span class="hljs-type">int</span> bAncestorNode = <span class="hljs-built_in">findAncestorNode</span>(b);<br>    <span class="hljs-keyword">if</span>(aAncestorNode == bAncestorNode)&#123; <span class="hljs-keyword">return</span>; &#125;<br>    <span class="hljs-keyword">if</span>(height[aAncestorNode] &gt;= height[bAncestorNode]) &#123;<br>        parent[bAncestorNode] = aAncestorNode;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        parent[aAncestorNode] = bAncestorNode;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(height[aAncestorNode] == height[bAncestorNode]) &#123;<br>        height[aAncestorNode]++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是我们发现如果该并查集使用了路径压缩的搜索，那么树的路径被压缩，那么height可能并不是实际的高度，而是高度的上界，称rank(秩）。秩是高度的上界，所以这个合并是基于秩的合并，而非基于高度的合并。</p><p>此时我们就可以解决一些有关简单的并查集的问题</p><p><a href="https://leetcode.cn/problems/number-of-provinces/">547. 省份数量</a></p><p>如果要求并查集(union-find-set)中集合的大小，那么怎么做呢？我们用一个数组存储集合的大小，a集合的大小从size[findAncestorNode(a)]找。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">findAncestorNode</span>(a) == <span class="hljs-built_in">findAncestorNode</span>(b)) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    size[<span class="hljs-built_in">findAncestorNode</span>(b)] += size[<span class="hljs-built_in">findAncestorNode</span>(a)];<br>    parent[<span class="hljs-built_in">findAncestorNode</span>(a)] = <span class="hljs-built_in">findAncestorNode</span>(b);<br>&#125;<br></code></pre></td></tr></table></figure><p>这样我们就有了UnionFindSet类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">UnionFindSet</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> * size;<br>    <span class="hljs-type">int</span> * rank;<br><span class="hljs-type">int</span> * parents;<br><span class="hljs-type">int</span> maxCount;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">UnionFindSet</span>(<span class="hljs-type">int</span> maxCount) &#123;<br>        parents = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[maxCount + <span class="hljs-number">1</span>];<br>        rank = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[maxCount + <span class="hljs-number">1</span>];<br>        size = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[maxCount + <span class="hljs-number">1</span>];<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= maxCount; i++) &#123;<br>            rank[i] = <span class="hljs-number">1</span>;<br>            parents[i] = i;<br>            size[i] = <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <br>    ~<span class="hljs-built_in">UnionFindSet</span>() &#123;<br>        <span class="hljs-keyword">delete</span>[] parents;<br>        <span class="hljs-keyword">delete</span>[] rank;<br>        <span class="hljs-keyword">delete</span>[] size;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findAncestorNode</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(a &gt; maxCount) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span>(parents[a] != a) &#123;<br>            parents[a] = <span class="hljs-built_in">findAncestorNode</span>(parents[a]);    <br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> parents[a];<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isConnected</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">findAncestorNode</span>(a) == <span class="hljs-built_in">findAncestorNode</span>(b);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(a &gt; maxCount || b &gt; maxCount) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <br>        <span class="hljs-type">int</span> aAncestorNode = <span class="hljs-built_in">findAncestorNode</span>(a);<br>        <span class="hljs-type">int</span> bAncestorNode = <span class="hljs-built_in">findAncestorNode</span>(b);<br>        <br>        <span class="hljs-keyword">if</span>(aAncestorNode == bAncestorNode) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span>(rank[aAncestorNode] &gt;= rank[bAncestorNode]) &#123;<br>            parents[bAncestorNode] = aAncestorNode;<br>            size[aAncestorNode] += size[bAncestorNode];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            parents[aAncestorNode] = bAncestorNode;<br>            size[bAncestorNode] += size[aAncestorNode];<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span>(rank[aAncestorNode] == rank[bAncestorNode]) &#123;<br>            rank[aAncestorNode] += rank[bAncestorNode];<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getSetSize</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(a &gt; maxCount) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> size[<span class="hljs-built_in">findAncestorNode</span>(a)];<br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>15. 哈希表</title>
    <link href="/2024/01/07/AcwingBasicCourse/15/"/>
    <url>/2024/01/07/AcwingBasicCourse/15/</url>
    
    <content type="html"><![CDATA[<p>哈希表一种搜索，查询，删除操作时间复杂度为 O(N) 的表，但遍历，找最大值的操作实现时间复杂度较高。</p><h2 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h2><p>普通表需要遍历搜索才能知道元素的位置。但哈希表可以用哈希函数通过key算出下标位置。在理想的情况下，哈希表的查找存储删除效率达到O（1）。但是较多的情况映射到更少种可能的下标位置，必然会出现不同key出现同一个hash值的情况，称哈希冲突，那么如何解决哈希冲突呢？</p><p>首先一定要选择一个好的哈希函数，减少哈希冲突。</p><p>对于非负整数，哈希函数可以为 hash(x) = key \div tablesize ，向下取整。需要注意，如果key是负数，会求余出负数，其哈希函数可以为 hash(x) = (key \div tablesize+tablesize) \div tablesize</p><p>注意：tablesize取质数才能实现到 [0,tablesize-1]的较好映射</p><p>对于字符串，常这样做 hash(str) = str[0] \times P^{n-1} + str[1] \times P^{n-2} + … + str[n-1] \times P^{0}</p><h2 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h2><p>1. 分离链接法</p><p>同一个hash值的元素用同一链表存储起来。下面代码的链表使用数组实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> table[maxN];<br><span class="hljs-type">int</span> values[maxN];<br><span class="hljs-type">int</span> nexts[maxN];<br><span class="hljs-type">int</span> index = <span class="hljs-number">1</span>;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> ((x % maxN) + maxN) % maxN;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-type">int</span> pos = <span class="hljs-built_in">hash</span>(x);<br>    <br>    values[index] = x;<br>    nexts[index] = table[pos];<br>    table[pos] = index;<br>    index++;<br>&#125; <br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-type">int</span> pos = <span class="hljs-built_in">hash</span>(x);<br>    <span class="hljs-type">int</span> nodePos = table[pos];<br>    <br>    <span class="hljs-keyword">while</span>(nodePos != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span>(values[nodePos] == x) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        nodePos = nexts[nodePos];<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>2. 开放寻址法</p><p>若A元素映射的单元已经被使用，则向右寻找最近的可用单元，下面使用的是线性探测法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-type">int</span> pos = <span class="hljs-built_in">hash</span>(x);<br>    <br>    <span class="hljs-keyword">while</span>(datas[pos] != null &amp;&amp; pos &lt; maxN) &#123;<br>        pos++;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span>(pos &gt;= maxN) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Error&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    datas[pos] = x;<br>&#125; <br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-type">int</span> pos = <span class="hljs-built_in">hash</span>(x);<br>    <br>    <span class="hljs-keyword">while</span>(pos &lt; maxN) &#123;<br>        <span class="hljs-keyword">if</span>(datas[pos] == x) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(datas[pos] == null) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        pos++;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如何表示单元是否可用呢，找不可能等于元素的值，比如元素范围为 [-10^9,10^9] ，可以取<em>INT</em>_<em>MAX，但我们一般不取，一是容易溢出，二是赋值没法用memset。我们一般用</em>0x3f3f3f3f，它是一个10^9级别的数，它的两倍不大于INT_MAX，每个字节是0x3f，可用nemset赋值。</p><p>3. 再散列</p><p>当元素过多时，扩大哈希表容量，但耗时长。</p><p>4. 双散列</p><p>当发生哈希冲突时，使用第二个哈希函数作为距离增量，找距离为 hash2(x),2hash2(x),…….,nhash2(x) 的可用单元。</p><h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><p><img src="https://pic3.zhimg.com/v2-7e0d8cbb3b253aa65e85168daa4f4a9e_b.jpg" alt=""></p><p>比较[l1,r1],和[l2,r2]的字符串是否相等，可以转化为比较字符串的哈希值是否相等，那么我们就必须保证哈希值不冲突，但显然字符串范围远远大于哈希值范围，故不可能发生冲突。所以我们只能尽可能地减少冲突。要让哈希值的范围尽可能的大，用unsigned long long，存在的情况为2^64 - 1。我们将字符串的哈希值定义为</p><p>hash(str) = str[0] \times P^{n-1} + str[1] \times P^{n-2} + … + str[n-1] \times P^{0} (P &gt; 127)</p><p>显然[l,r]的值可以前缀和思想进行求解</p><p>hash(s_{1}s_{2}) = hash(s1s3) + hash(s2)</p><p>其中s3为n个空字符，n为s2的长度</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ull;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> P = <span class="hljs-number">127</span>;<br>ull presums[N];<br>ull powP[N];<br><br><span class="hljs-function">ull <span class="hljs-title">getHash</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> presums[r] - presums[l - <span class="hljs-number">1</span>] * powP[r -  l + <span class="hljs-number">1</span>];<br>&#125; <br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span>&#123;<br>    ...<br><br>    presums[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    powP[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        powP[i] = powP[i - <span class="hljs-number">1</span>] * P;<br>        presums[i] = presums[i - <span class="hljs-number">1</span>] * P + str[i - <span class="hljs-number">1</span>];<br>    &#125;<br>    <br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>14. 字典树（Trie）</title>
    <link href="/2024/01/07/AcwingBasicCourse/14/"/>
    <url>/2024/01/07/AcwingBasicCourse/14/</url>
    
    <content type="html"><![CDATA[<p>Trie树，即字典树，又称单词查找树或键树，经常应用是用于统计和排序大量的字符串。</p><p><img src="https://pic1.zhimg.com/v2-6347b71007cacd7954c5cffb8289b548_b.jpg" alt=""></p><p>字典树，从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串。除根节点外，每一个节点的位置代表了一个字符串。用数组实现，它的数据存储这样的，0为根节点的位置，next[i][c - ‘a’] 为位置为i的节点的字符c边的节点位置，若为0，则没有这个节点。cnt为该节点字符串出现次数，index为可用节点的位置</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> cnt[maxN];<br><span class="hljs-type">int</span> next[maxN];<br><span class="hljs-type">int</span> index = <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>插入操作：从根结点开始，看是根节点是否有一条边（是第1个字符的），如果没有则创建，然后再对那条边连向的节点进行第2个字符操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(string str)</span> </span>&#123;<br>    <span class="hljs-type">int</span> pos = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c : str) &#123;<br>        <span class="hljs-type">int</span> integer = c - <span class="hljs-string">&#x27;a&#x27;</span>;<br>    <br>        <span class="hljs-keyword">if</span>(next[pos][integer] == <span class="hljs-number">0</span>) &#123;<br>            next[pos][integer] = index;<br>            index++;<br>        &#125;<br>        <br>        pos = next[pos][integer];<br>    &#125;<br>    <br>    cnt[pos]++;<br>&#125;<br></code></pre></td></tr></table></figure><p>查询操作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(string str)</span> </span>&#123;<br>    <span class="hljs-type">int</span> pos = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c : str) &#123;<br>        <span class="hljs-type">int</span> integer = c - <span class="hljs-string">&#x27;a&#x27;</span>;<br>        <br>        <span class="hljs-keyword">if</span>(next[pos][integer] == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <br>        pos = next[pos][integer];<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> cnt[pos];<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>题目</strong>：在给定的 N 个整数 A_{1},A_{2}…….A_{n} 中选出两个进行 xor （异或）运算，得到的结果最大是多少？</p><p>可以构造一个Trie，但一个节点的边最多两条，要么是0，要么是1。从最高位开始插入节点，从根结点到节点的路径为该整数。</p><p>然后遍历N个整数，从最高位（31位）找与它相反的，然后再从更低一位找，这样找到的必然是与该整数异或得到的最大结果。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>13. kmp</title>
    <link href="/2024/01/07/AcwingBasicCourse/13/"/>
    <url>/2024/01/07/AcwingBasicCourse/13/</url>
    
    <content type="html"><![CDATA[<script type="math/tex; mode=display">E=mc^2</script><script type="math/tex; mode=display">hash(str) = str[0] \times P^{n-1} + str[1] \times P^{n-2} + ... + str[n-1] \times P^{0}</script>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>12. 单调栈和单调队列</title>
    <link href="/2024/01/07/AcwingBasicCourse/12/"/>
    <url>/2024/01/07/AcwingBasicCourse/12/</url>
    
    <content type="html"><![CDATA[<p>单调栈是满足单调性的栈。若栈从底部到顶部有严格单调递增，则称为单调递增栈。若栈从底部到顶部有严格单调递减，则称为单调递减栈。</p><p>单调栈可用来解决寻找左边或右边第一个与它构成某种特定大小关系的数，比如寻找左边第一个比它小的数。我们来看看一道题目。</p><p><strong>题目</strong>：给定一个长度为 N 的整数数列，输出每个数左边第一个比它小的数，如果不存在则输出 -1 。</p><p>我们可以维护一个单调递增栈：从左到右遍历，依次放入元素，若栈顶元素大于放入元素，那么则不断去除栈顶元素，再放入元素。此时若元素可以放入，则如果栈有元素，则栈顶必然为左边第一个小于它的数。</p><p>栈中包含了该元素的左边部分元素，只考虑左边的部分元素，栈顶确实是第n个数的解。但是在放入前n-1个数时，我们还去除了一些元素，那些元素有没有可能才是第n个数的解呢？实际上不可能，在放入前n-1个数中，新放入的元素比去除的元素更优，更优的意思是指更靠近右边，比它更小，所以一旦放入新元素，那些比它大的元素，还比它靠左的元素不可能成为解。</p><p><strong>练习</strong>：给定一个长度为 N 的整数数列，输出每个数右边第一个比它大的数的下标，如果不存在则输出0 。</p><p>与上面的题目不同，它要求找到右边的。实际上我们把reverse数列，就变成找左边的。还有一处不同，是找下标。我们另创建一个栈，来存储下标就行，跟单调栈执行一样的操作。</p><p>单调队列是满足单调性的队列。单调递增队列是从队尾到队头单调递增的队列，单调递减队列是从队尾到队头单调递减的队列。</p><p><img src="https://pic2.zhimg.com/v2-92ec976de7749c4a6db10d72f05f9721_b.jpg" alt=""></p><p>题目. 滑动窗口</p><p>我们发现这个题目与上一题比较明显的区别是，每次进行操作时，有滑动窗口，需要去除队首元素，而队列正好符合先进先出的这个特点，所以我们考虑用单调队列。首先考虑最小值，最优指的是越小，越靠右，要舍弃先前太大的元素使得无法构成单调递增栈。</p><p>这道题我在一个地方写错了，我的思路是用i代表窗口中最后一个元素下标，从0遍历到n-1,那么什么时候舍弃因滑动窗口而丢掉的元素呢？我写成了当i&gt;=k时，也就是形成k个元素窗口，并且开始滑动时，实际上是不对的。因为构造单调队列时，实际上已经舍弃了一些元素。正确的做法是，我们要判断队首元素的下标是不是滑动窗口左边的第一个元素的下标</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1000100</span>;<br><span class="hljs-type">int</span> indexs[N];<br><span class="hljs-type">int</span> front = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> rear = <span class="hljs-number">-1</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; numbers;<br>    <span class="hljs-type">int</span> n, k;<br>    <br>    cin &gt;&gt; n &gt;&gt; k;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-type">int</span> x;<br>        cin &gt;&gt; x;<br>        numbers.<span class="hljs-built_in">push_back</span>(x);<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">if</span>(i - k == indexs[front]) &#123;<br>            front++;<br>        &#125;<br>        <br>        <span class="hljs-keyword">while</span>(rear &gt;= front &amp;&amp; numbers[indexs[rear]] &gt;= numbers[i]) &#123;<br>            rear--;<br>        &#125;<br>        <br>        indexs[++rear] = i;<br>    <br>        <span class="hljs-keyword">if</span>(i &gt;= k - <span class="hljs-number">1</span>) &#123;<br>            cout &lt;&lt; numbers[indexs[front]] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>    &#125;<br>    <br>    front = <span class="hljs-number">0</span>; rear=<span class="hljs-number">-1</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    <br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">if</span>(i - k == indexs[front]) &#123;<br>            front++;<br>        &#125;<br>        <br>        <span class="hljs-keyword">while</span>(rear &gt;= front &amp;&amp; numbers[indexs[rear]] &lt;= numbers[i]) &#123;<br>            rear--;<br>        &#125;<br>        <br>        indexs[++rear] = i;<br>    <br>        <span class="hljs-keyword">if</span>(i &gt;= k - <span class="hljs-number">1</span>) &#123;<br>            cout &lt;&lt; numbers[indexs[front]] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>11. 队列</title>
    <link href="/2024/01/07/AcwingBasicCourse/11/"/>
    <url>/2024/01/07/AcwingBasicCourse/11/</url>
    
    <content type="html"><![CDATA[<p>我们讲讲队列的数组实现。在算法竞赛中，为了快速写出队列，允许队列浪费空间。我们可以这样写</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><br><span class="hljs-type">int</span> front, rear;<br><span class="hljs-type">int</span> datas[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>    front = <span class="hljs-number">0</span>;<br>    rear = <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>    front++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    datas[++rear] = x;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> front &gt; rear;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">front</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> datas[front];<br>&#125;<br></code></pre></td></tr></table></figure><p>这个写法较为简单，不过多赘述。如果我们有时间，我们可以用不浪费空间的一种数组实现方式。这种方式就是循环队列。存在一种情况：front达到size-2，rear达到size-1，此时该队列假满，还有许多空间没有被使用。此时，如果继续push，往data[rear+1]放数据，必然越界。怎么办呢？我们可以让它回到原点即0，继续使用。即rear = (rear + 1) % N，front也是做这样的运算。</p><p>那么用这种方式，该如何判定队列的大小呢？看front-rear的绝对值，但是它只有N种情况，但是队列大小有N+1种情况，所以无法判定队列大小。</p><p>此时我们可以这样做，那就是规定(rear + 1) % size = front为满，这也就意味着队列中永远有一个元素没有办法被用到，队列实际最大容量为N-1，</p><p>规定front=rear=0为初始情况，front指向的是有元素的前面一个区域，永远指向无元素的区域，当队列大小大于0时，rear指向最后一个元素的下标。队列最大大小为maxLength，则数组大小为N = maxLength + 1</p><p>队列为空：有规定知，rear==front</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;<br>   <span class="hljs-keyword">return</span> rear == front;<br>&#125;<br></code></pre></td></tr></table></figure><p>队列已满：rear先前走一步与front相等</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isFull</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (rear + <span class="hljs-number">1</span>) % N == front; <span class="hljs-comment">// N代表数组的大小</span><br>&#125;<br></code></pre></td></tr></table></figure><p>获得队列长度（结合具体例子去想，元素为空，元素为满的情况）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getLength</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> l = (rear - front);<br>         <br>    <span class="hljs-keyword">return</span> (l &gt;= <span class="hljs-number">0</span>) ? l : (l + N + <span class="hljs-number">1</span>); <br>&#125;<br></code></pre></td></tr></table></figure><p>push和pop操作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isFull</span>()) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;FULL&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    rear = (rear + <span class="hljs-number">1</span>) % N;<br>    datas[rear] = x;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isEmpty</span>()) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Empty&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    front = (front + <span class="hljs-number">1</span>) % N;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>10. 栈（未完）</title>
    <link href="/2024/01/07/AcwingBasicCourse/10/"/>
    <url>/2024/01/07/AcwingBasicCourse/10/</url>
    
    <content type="html"><![CDATA[<p>栈是一个先进后出的结构，它可以使用指针实现。不过与链表同理，在算法竞赛一般不用，一般使用数组进行实现。同样地，该代码只保证输入进行合法的操作并且不考虑超过栈大小的问题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> top = <span class="hljs-number">-1</span>;<br><span class="hljs-type">int</span> datas[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    datas[++top] = x; <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>    top--;  <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> top &lt;= <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getTop</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(top &gt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> datas[top];<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来，我们利用栈来求解中缀表达式。</p><p>用两个栈保存数字和操作符，然后遍历字符串</p><p>如果遇到数字，那么存储下来。</p><p>如果遇到(，则push到运算符栈</p><p>如果遇到)，则不断eval，直至遇到(,并将(弹出</p><p>如果栈存在运算符，而且当前运算符优先级小于栈顶运算符优先级，则不断运算，然后push当前运算符。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>9. 链表</title>
    <link href="/2024/01/07/AcwingBasicCourse/9/"/>
    <url>/2024/01/07/AcwingBasicCourse/9/</url>
    
    <content type="html"><![CDATA[<p>链表可以用指针来实现，较为简单熟悉，这里不再赘述。但是，指针实现每次插入和删除都要调用malloc和free函数，而这来回从用户态切换到内核态，极其消耗时间，所以写算法题一般我们不用指针实现的链表，而是用数组实现。（当然可以使用内存分配器减少切换内核态的次数）</p><p>用指针实现的链表数据结构是这样的，并且有用到内存分配函数，这就启发我们：如果要是要数组实现，也要有对于的存储结构来存储next，分配内存，存储value</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<br>    <span class="hljs-type">int</span> value;<br>    Node * next;<br>&#125;;<br></code></pre></td></tr></table></figure><p>在这里，我们只说明在算法竞赛数组实现方案，不考虑内存浪费的问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> value[N]; <span class="hljs-comment">// 每个节点的值</span><br><span class="hljs-type">int</span> next[N]; <span class="hljs-comment">// 每个节点的next</span><br><span class="hljs-type">int</span> head; <span class="hljs-comment">// 指向头元素的地址</span><br><span class="hljs-type">int</span> index; <span class="hljs-comment">// 保存内存分配的信息</span><br></code></pre></td></tr></table></figure><p>在数组实现中，地址不是内存地址，而是数组的索引，-1表示nullptr。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>    head = <span class="hljs-number">-1</span>;<br>    index = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insertToHead</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    value[index] = x;<br>    next[index] = head;<br>    head = index;<br>    index++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> x)</span> </span>&#123; <span class="hljs-comment">//这里的insert是向第k次插入的元素后面插入元素，而不是从左到右第k个元素</span><br>    value[index] = x;<br>    next[index] = next[k];<br>    next[k] = index;<br>    index++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span> </span>&#123; <span class="hljs-comment">// 删除第k次插入的元素后面的那一个元素</span><br>    next[k] = next[next[k]];<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的代码并不考虑内存浪费，只考虑效率。代码也不考虑边界问题，需题目进行合法操作和数组大小N足够。</p><p>上述是单链表，不方便对某个元素的前面插入元素，也不方便对末尾插入元素。我们引入双链表，指针实现的双链表的数据结构是这样的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<br>    Node * right;<br>    Node * left;<br>    <span class="hljs-type">int</span> value;<br>&#125;;<br></code></pre></td></tr></table></figure><p>其对应的数组数据存储是这样的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> right[N];<br><span class="hljs-type">int</span> left[N];<br><span class="hljs-type">int</span> value[N];<br><span class="hljs-type">int</span> index;<br></code></pre></td></tr></table></figure><p>我们此时设定第一个节点和第二个节点分别为head和end，单纯方便处理值，不存储任何值。此时数组从2开始，才开始存储值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>    index = <span class="hljs-number">2</span>;<br>    right[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    left[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span> </span>&#123;<br>    <span class="hljs-type">int</span> pos = k + <span class="hljs-number">1</span>;<br>    <br>    right[left[pos]] = right[pos];<br>    left[right[pos]] = left[pos];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InsertLeft</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-type">int</span> pos = k + <span class="hljs-number">1</span>;<br>    <br>    value[index] = x;<br>    left[index] = left[pos];<br>    right[index] = pos;<br>    right[left[index]] = index;<br>    left[right[index]] = index;<br>    <br>    index++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InsertRight</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-type">int</span> pos = k + <span class="hljs-number">1</span>;<br>    <br>    value[index] = x;<br>    left[index] = pos;<br>    right[index] = right[pos];<br>    right[left[index]] = index;<br>    left[right[index]] = index;<br>    <br>    index++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InsertToHead</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-built_in">IR</span>(<span class="hljs-number">-1</span>, x);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InsertToBack</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-built_in">IL</span>(<span class="hljs-number">0</span>, x);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>8. 双指针算法</title>
    <link href="/2024/01/07/AcwingBasicCourse/8/"/>
    <url>/2024/01/07/AcwingBasicCourse/8/</url>
    
    <content type="html"><![CDATA[<p><strong>题目</strong>：给定一个长度为 n 的整数序列，请找出最长的不包含重复的数的连续区间，输出它的长度。</p><p>这个问题可以进行暴力求解，i为起点，j为终点</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; i &lt; n; j++) &#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= j; i++) &#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(numbers, i, j)) &#123;<br>            maxLength = <span class="hljs-built_in">max</span>(maxLength, j - i + <span class="hljs-number">1</span>)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其时间复杂度为 O(N^2) ，注意到进行了很多重复的运算。我们看是否存在单调性，令i为使得[i,j]为最长序列的值，显然单调性为j向右移动，则i必然向右动或者不动，不可能往左动。</p><p>即当 j = k 时，最长序列为 [i_{k}, k] ，那么当 j= k + 1 ,必然满足 i_{k+1} &gt;= i_{k} 。因为如果 i_{k+1} <i\_{k} ，则说明 \[i\_{k} - n, k \] 不存在重复数字，而上一步求解的 \[i\_{k}, k\] 说明 \[i\_{k} - 1, k \] 必然存在重复元素，二者矛盾，则 i\_{k+1} < i{k} 不成立，故 i\_{k+1} >= i_{k} 。</p><p>因此i只需要往右运动，不需要回溯，就可以完成对问题的求解。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>    <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">check</span>(numbers, i, j)) &#123;<br>        i++;<br>    &#125;<br>        <br>    maxLength = <span class="hljs-built_in">max</span>(maxLength, j - i + <span class="hljs-number">1</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>其中，check()这样写耗时较少。开辟一个数组，记录在最长序列中数据出现的次数，在i和j移动过程中，不断进行更新。若j向右移动，则新加入的这个数字出现次数加1，则此时该序列有重复元素，则必然新加入的这个数字出现了2次，不断让i右移，使得[i,j]为最长不重复序列。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>        s[numbers[j]]++;<br>        <br>            <br>        <span class="hljs-keyword">while</span>(s[numbers[j]] &gt; <span class="hljs-number">1</span>) &#123;<br>            s[numbers[i]]--;<br>            i++;<br>        &#125;<br>    <br>        <br>        maxLength = <span class="hljs-built_in">max</span>(maxLength, j - i + <span class="hljs-number">1</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>再看另外一道题</strong>：给定两个升序排序的有序数组 A和B ，以及一个目标值 x。 数组下标从0开始。 请你求出满足 A[i] + B[j] = x 的数对 (i,j) ，数据保证有唯一解。其中，n,m,x ，分别表示 A 的长度，B 的长度以及目标值 x 。</p><p>先看看暴力算法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>        <span class="hljs-keyword">if</span>(A[i] + B[j] == x) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>, i, j);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们来看单调性，我们将问题转换为在不同i的情况下， A[i] + B[j] &gt;= x 的j最小值。假如i向右移动，那么j会向右移动吗，显然不会。显然A[i+1]可能变大或不变，则对于的B可能变小或不变，则j向左移动或不动。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = m - <span class="hljs-number">1</span>; ; i++) &#123;<br>    <span class="hljs-keyword">while</span>(A[i] + B[j - <span class="hljs-number">1</span>] &gt;= x) &#123;<br>        j--;<br>    &#125;<br>        <br>    <span class="hljs-keyword">if</span>(A[i] + B[j] == x) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>, i,j);<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>7. 区间合并</title>
    <link href="/2024/01/07/AcwingBasicCourse/7/"/>
    <url>/2024/01/07/AcwingBasicCourse/7/</url>
    
    <content type="html"><![CDATA[<p><strong>题目</strong>：给定 n 个区间 [l,r] ，要求合并所有有交集的区间。 注意如果在端点处相交，也算有交集。 输出合并完成后的区间个数。</p><p><strong>数据范围</strong>： 1≤n≤100000, −109≤l≤r≤109</p><p>先对这n个区间进行排序（先根据l从小到大，若相等再根据r的大小进行排序）。在排序完后，则可以合并的区间必然在相邻位置，是连在一起的。因此，我们从第一个区间开始向右合并区间，其得到的区间必然不可再合并。设正在合并的区间为[start, end]。如果可以合并区间，那么我们对正在合并的区间范围进行更新。如果不能合并区间，则我们将正在合并的区间调整为该区间，并让amount++。</p><p>排序完后，可以合并的区间必然在相邻位置，是连在一起的，则从左到右合并区间完成后，必然合并区间完成。我们进行证明：在算法完成好后，第k个区间与后面区间必然无法合并，而且无法与前面区间合并。因为在合并时，第k个区间无法与第k+1个区间合并，则必然存在 l_{k+1} &gt; r_{k} ，又因为这些区间排好序，则 l_{k + n} &gt;= l_{k + n -1 } &gt;= … &gt;= l_{k + 1} &gt; r_{k} ，故第k个区间与后面区间必然无法合并。对前面k-1个区间同理，必然无法与后面区间合并，也就是说前面k-1个区间无法与第k个区间合并。则在算法完成好后，第k个区间与其他区间必然无法合并。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;<br><br>    cin &gt;&gt; n;<br><br>    vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; ranges;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-type">int</span> start, end;<br><br>        cin &gt;&gt; start &gt;&gt; end;<br><br>        ranges.<span class="hljs-built_in">push_back</span>(&#123;start, end&#125;);<br>    &#125;<br><br>    <span class="hljs-type">int</span> amounts = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-built_in">sort</span>(ranges.<span class="hljs-built_in">begin</span>(), ranges.<span class="hljs-built_in">end</span>());<br><br>    <span class="hljs-type">int</span> l = <span class="hljs-number">-3e9</span>, r = <span class="hljs-number">-3e9</span>;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> range : ranges) &#123;<br>        <span class="hljs-keyword">if</span>(range.first &gt; r) &#123;<br>            amounts++;<br>            l = range.first;<br>            r = range.second;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span>(range.second &gt; r) &#123;<br>                r = range.second;<br>            &#125;<br>        &#125;<br>    &#125;<br><br><br>    cout &lt;&lt; amounts &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>6. 区间和（离散化）</title>
    <link href="/2024/01/07/AcwingBasicCourse/6/"/>
    <url>/2024/01/07/AcwingBasicCourse/6/</url>
    
    <content type="html"><![CDATA[<p><strong>问题：</strong>假定有一个无限长的数轴，数轴上每个坐标上的数都是0 。 现在，我们首先进行 n 次操作，每次操作将某一位置 x 上的数加 c 。 接下来，进行 c 次询问，每个询问包含两个整数 l 和 r ，你需要求出在区间 [l,r] 之间的所有数的和。</p><p><strong>数据范围：</strong> −10^9≤x≤10^9，1≤n,m≤10^5，−10^9≤l≤r≤10^9，−10000≤c≤10000</p><p>这道题显然不能直接用数组进行存储，因为数的范围太大，其数组大小至少是GB级别的。但是我们注意虽然数的范围很大，但是数的个数只有10^5个，我们可以将数从小到大映射到1~n。（假设有n个数）。那么如何映射呢。先将所有数进行排序，并删除重复的元素，其映射值为 position + 1，position可以通过二分搜索得到。</p><p>在存储完后，需要对某个位置加上c，并求区间和，可以用前缀和的方法求解区间和。但是l和r不一定属于x的集合，如何映射到x呢？注意到求解区间 [l,r]之间所有数的和，l可以映射到第一个大于等于l的数，r可以映射到第一个小于等于r的数。注意到，要判断l和r是否是有效的，也就是判断之间是否存在数，不存在数则返回0，存在则返回 presum[rt] - presum[lt - 1]。</p><p>实际上如果想更简单的话，可以在最开始把numbers和l和r的所有数都放一起映射。这样就查询时候便简单很多。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>3. 前缀和与差分</title>
    <link href="/2024/01/06/AcwingBasicCourse/3/"/>
    <url>/2024/01/06/AcwingBasicCourse/3/</url>
    
    <content type="html"><![CDATA[<p><strong>问题1：输入一个长度为n的整数序列。接下来再输入m个询问，每个询问输入一对l,r。对于每个询问，输出原序列中从第l个数到第r个数的和。</strong></p><p>如果直接暴力求解，注意到在m次查询中，会对某些元素进行重复的求和。</p><p>不妨构造前缀和数组 presum[n] = nums[1]+nums[2]+…+nums[n]，第l个数到第r个数的和可化为presum[r] - presum[l-1]。那么问题的求解就有两个步骤：</p><ol><li>构造前缀和数组</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>   s[i] = s[i - <span class="hljs-number">1</span>] + datas[i];<br>&#125;<br></code></pre></td></tr></table></figure><p>2. 利用前缀和数组求出给定序列的和</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, s[r] - s[l - <span class="hljs-number">1</span>]);<br></code></pre></td></tr></table></figure><p>显然当查询次数很多时，后者做法较省时间。</p><p><strong>问题2: 输入一个n行m列的整数矩阵，再输入q个询问，每个询问包含四个整数x1,y1,x2,y2，表示一个子矩阵的左上角坐标和右下角坐标。对于每个询问输出子矩阵中所有数的和。</strong></p><p>我们受问题1的启发，希望构造二维前缀和数组，求解子矩阵的和。</p><p>presum[x][y] = num[x][y] + presum[x][y - 1] + presum[x - 1][y] - presum[x - 1][y -1]</p><p>得到二维前缀和数组，我们该如何求解子矩阵的和呢？</p><p>子矩阵的和为 presum[x2][y2] - presum[x2][y1 -1] - presum[x1 - 1][y2] + presum[x1 - 1][y1 - 1]</p><p><strong>问题3: 输入一个长度为n的整数序列。接下来输入m个操作，每个操作包含三个整数l,r,c，表示将序列中[l,r]之间的每个数加上c。</strong></p><p>若直接进行暴力求解，会算m*(r-l+1)次。注意到若进行多次操作，对多个区域进行多次加数，实际上可一次性加这些数的和，存在时间上的优化可能性。若给定的整数序列为nums的前缀和数组，则称nums为presum的差分数组。现有前缀和数组，如何构造出差分数组。注意到 presum[n] = nums[1]+nums[2]+…+nums[n]，则nums[n] = presum[n] - presum[n-1]。</p><p>有了差分数组，我们对nums[l]加上c，显然其对应的前缀和数组从l到n均有加c。为了使得r+1到n不加上c，再对nums[r + 1]减上c。此时，其对应的前缀和数组从l到r均有加c，而且其他位置元素不变。再根据m次操作后的差分数组，可得到其对应的前缀和数组，也就是题目所求的整数序列。</p><p><strong>问题4: 输入一个n行m列的整数矩阵，再输入q个操作，每个操作包含五个整数x1,y1,x2,y2,c，其中(x1,y1)和(x2,y2)表示一个子矩阵的左上角坐标和右下角坐标。每个操作都要将选中的子矩阵中的每个元素的值加上c。请你将进行完所有操作后的矩阵输出。</strong></p><p>受问题3启发，想由二维前缀和数组得到二维差分数组。注意到prenum[x][y] = num[x][y] + prenum[x][y - 1] + prenum[x - 1][y] - prenum[x - 1][y -1], 得到nums[x][y] = prenum[x][y] - prenum[x-1][y] - prenum[x][y-1] + prenum[x-1][y-1]。</p><p>得到二维差分数组后，该如何对二维差分数组操作，使得其对应的二维前缀和数组满足操作后要求。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">nums[x1][y1] +=c<br>nums[x2+<span class="hljs-number">1</span>][y1] -=c<br>nums[x1][y2+<span class="hljs-number">1</span>] -= c<br>nums[x2+<span class="hljs-number">1</span>][y2+<span class="hljs-number">1</span>] +=c<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>4. QUICKSORT</title>
    <link href="/2024/01/06/AcwingBasicCourse/4/"/>
    <url>/2024/01/06/AcwingBasicCourse/4/</url>
    
    <content type="html"><![CDATA[<p>若一些数可以分为两个连续的部分，满足性质的部分和不满足性质部分，则我们称这些数具有二段性，那么我们就可以进行二分搜索。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>5. 归并排序与求逆序对数量</title>
    <link href="/2024/01/06/AcwingBasicCourse/5/"/>
    <url>/2024/01/06/AcwingBasicCourse/5/</url>
    
    <content type="html"><![CDATA[<p>归并排序的步骤分为</p><ol><li>先将序列等分为两个小序列</li><li>再递归处理小序列，两个小序列此时有序</li><li>将两个小序列合并，使得整个序列合并</li></ol><p>其核心点在于如何合并小序列。</p><ol><li>创建一个temps数组，来暂时存储合并后的结果</li><li>不断找到两个小序列的还未处理的最小元素，将其放到temps数组。注意到两个序列都已经排好序，两个序列的最小未处理元素必然在左边（第一个序列是l，第二个序列是m+1）。直到有一边用完为止</li><li>此时，在二个序列中，至多只有一个序列有元素，而且是有序的，所以从左到右将未处理的元素放到小序列即可。</li><li>最后将temps数组的结果放到原序列中。</li></ol><p>归并排序可以用来求逆序对的数量</p><p>我们依然将序列等分为两个小序列，整个序列的逆序对 = 左边序列中的逆序对 + 右边序列的逆序对 + 左边序列中的数字与右边序列中的数字产生的逆序对。</p><p>因此逆序对求解可分为以下步骤</p><ol><li>求左边序列的逆序对和右边序列的逆序对（归并排序并求两个序列的逆序对）</li></ol><p>注意到左边序列和右边序列改变顺序，并不会影响左边序列中的数字与右边序列中的数字产生的逆序对的数量。所以可以对左边序列和右边序列进行排序后，再求左边序列中的数字与右边序列中的数字产生的逆序对的数量。</p><p>2. 求左边序列中的数字与右边序列中的数字产生的逆序对的数量</p><p>归并排序的合并过程中，合并时需要不断找到未处理的最小元素。若最小元素出现在左序列，则表明左序列的未处理的元素均小于右序列的未处理元素，不构成逆序对。若最小元素出现右序列，则左序列未处理的所有元素均小于右序列的所有未处理元素，构成逆序对。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>2. 高精度整数</title>
    <link href="/2024/01/06/AcwingBasicCourse/2/"/>
    <url>/2024/01/06/AcwingBasicCourse/2/</url>
    
    <content type="html"><![CDATA[<p><strong>问题1：高精度整数如何存储的呢？</strong></p><p>数组存储着各个位上的数，数组的第一位置存储着个位，第二位置存储着十位，以此类推。</p><p><strong>问题2：高精度整数如何进行输入与输出？</strong></p><p>读取输入的字符串，因为存储高精度整数数组第一个位置要存储个位，而字符串是从数的高位开始输出，则要从字符串的最后一位开始读起。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = num_str.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>    num.<span class="hljs-built_in">push_back</span>(num_str[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>那么如何进行输出呢？由于输出是从高位到低位，因此先从数组的最后一位输出。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = num.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, num[i]);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>问题3：如何比较高精度整数之间的大小？</strong></p><p>先比较两个数组的大小，若不相等，大的数组对应的整数大。若相等，则从高位开始比较，一直到低位。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; b)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(a.<span class="hljs-built_in">size</span>() != b.<span class="hljs-built_in">size</span>())&#123;<br>        <span class="hljs-keyword">return</span> a.<span class="hljs-built_in">size</span>() &gt; b.<span class="hljs-built_in">size</span>();<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = a.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-keyword">if</span>(a[i] &gt; b[i]) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a[i] &lt; b[i]) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>问题4：如何实现加法（高精度+高精度）</strong></p><p>受竖式加法启发，我们先是从最低位开始，一直到最高位，依次进行多个数相加，第一个数的位上的数，第二个数的位上的数，再加上上一位的进位。若它们的和大于或等于10，则对于下一位要进1，这一位是sum % 10。要注意在多个数相加时，注意不访问第1个数或第2个数不存在的位。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp; a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp; b)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(a.<span class="hljs-built_in">size</span>() &lt; b.<span class="hljs-built_in">size</span>()) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">add</span>(b, a);<br>    &#125;<br>    <br>    vector&lt;<span class="hljs-type">int</span>&gt; c;<br>    <span class="hljs-type">int</span> s = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; a.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        s += a[i];<br>        <br>        <span class="hljs-keyword">if</span>(i &lt; b.<span class="hljs-built_in">size</span>()) &#123;<br>            s += b[i];<br>        &#125;<br>        <br>        c.<span class="hljs-built_in">push_back</span>(s % <span class="hljs-number">10</span>);<br>        s /= <span class="hljs-number">10</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span>(s &gt; <span class="hljs-number">0</span>) &#123;<br>        c.<span class="hljs-built_in">push_back</span>(s);<br>    &#125;<br>   <br>    <span class="hljs-keyword">return</span> c;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>问题5：如何实现减法（高精度-高精度）</strong></p><p>首先为了保证算法的简单，我们只让算法考虑大的-小的，在解决问题前，先进行整数的比较，若小的-大的，则进行对换，保证大的-小的。</p><p>同样的考虑竖式减法，先从低位减起，t = a[i] - b[i]（要考虑是否存在） - t（上一位可能借位），若t&gt;=0，则不需要进位, 该位为t，并让借位为0，若t&lt;0，则该位为10+t，并让借位为1。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; a.<span class="hljs-built_in">size</span>(); i++) &#123;<br>    t = a[i] - t; <br>    <span class="hljs-keyword">if</span>(i &lt; b.<span class="hljs-built_in">size</span>()) &#123;<br>        t -= b[i];<br>    &#125; <br>    c.<span class="hljs-built_in">push_back</span>((t + <span class="hljs-number">10</span>) % <span class="hljs-number">10</span>);<br>    t = t &gt;= <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意到91 - 90 = 01，则需要去掉前导零</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span>(c.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; c.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>)&#123;<br>    c.<span class="hljs-built_in">pop_back</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>问题6：如何实现乘法（高精度 * 低精度）</strong></p><p>先从低位开始乘起，t =上一位的进位 + 这一位 * 低精度，进位为 t / 10，同时这一位为 t % 10。注意到所有位乘完后，得到的数可能大于原来高精度数，所以还要考虑t是否大于0。注意到 0 * 999 = 000，那么需要去掉前导零。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">mul</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp; a, <span class="hljs-type">const</span> <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; c;<br>    <br>    <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; a.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        t = t + a[i] * b;<br>        <br>        c.<span class="hljs-built_in">push_back</span>(t % <span class="hljs-number">10</span>);<br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">while</span>(t &gt; <span class="hljs-number">0</span>) &#123;<br>        c.<span class="hljs-built_in">push_back</span>(t % <span class="hljs-number">10</span>);<br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span>(c.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; c.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>) &#123;<br>        c.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> c;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>问题7：如何实现除法（高精度 / 低精度）（写错了）</strong></p><p>除法与前三个运算不同，它是从高位开始算起，r = 上一位没除完 * 10 + 这一位，注意到第一次 r / b 如果等于0，不需要放到结果，如果不是最后一次，需要放到结果，我们可以不管是第几次都放到c里，然后在最后去除前导零。这一位没除完的 = r % b。</p><p>注意到是从高位开始算起，因此此时数组第一位放到必然为高位，要reverse，然后去除前导零。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">div</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp; a, <span class="hljs-type">const</span> <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> &amp; r)</span> </span>&#123;<br>   vector&lt;<span class="hljs-type">int</span>&gt; c;<br>   <br>   r = <span class="hljs-number">0</span>;<br>   <br>   <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = a.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>       <br>       r = r *<span class="hljs-number">10</span> + a[i];<br><br>       c.<span class="hljs-built_in">push_back</span>(r / b);<br>       <br>       r %= b;<br>   &#125;<br>   <br>   <span class="hljs-built_in">reverse</span>(c.<span class="hljs-built_in">begin</span>(), c.<span class="hljs-built_in">end</span>());<br>   <br>   <span class="hljs-keyword">while</span>(c.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; c.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>) &#123;<br>        c.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<br>   <br>   <span class="hljs-keyword">return</span> c;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>1. 整数二分</title>
    <link href="/2024/01/06/AcwingBasicCourse/1/"/>
    <url>/2024/01/06/AcwingBasicCourse/1/</url>
    
    <content type="html"><![CDATA[<p>若一些数可以分为两个连续的部分，满足性质的部分和不满足性质部分，则我们称这些数具有二段性，那么我们就可以进行二分搜索。</p><p>对于一个升序或降序的数组，该数组必然满足二段性。例如，1 2 2 3 3 5</p><p><strong>问题1: 在一个升序数列中，如何得到某个数的开始位置</strong></p><p>升序数列必然可以分为两个部分，左边是不满足性质（不满足大于等于x），右边是满足性质（大于等于x的）。那么我们可以用整数二分得到满足性质的起始位置。但此时我们必不知道区间的边界在哪里。我们取middle，若它满足性质，则右边区间起始位置至少到m，即右边区间起始位置必然在在[l, m]，若为不满足性质，则可以知道不满足区间的部分的右边位置至少到m，现在则其要右边区间的起始位置不可能在[l,m]上，必然在[m+1, r]上。直到l &gt; r，此时l = r。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">SL</span><span class="hljs-params">(<span class="hljs-type">int</span> * datas, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <br>    <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = n - <span class="hljs-number">1</span>, m = (l + r) / <span class="hljs-number">2</span>; <br>    <br>    <span class="hljs-keyword">while</span>(l &lt; r) &#123;<br>        <span class="hljs-keyword">if</span>(datas[m] &gt;= x) &#123;<br>            r = m;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            l = m + <span class="hljs-number">1</span>;<br>        &#125;<br>        <br>        m = (l + r) / <span class="hljs-number">2</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>问题2：在一个升序数列中，得到元素的结束位置</strong></p><p>同理，这段数可分为两个部分，左边是满足性质的（小于等于x），右边是不满足性质（不小于等于x的。我们只要获得左区间的结束位置就可以获得元素的结束位置。但此时我们必不知道区间的边界在哪里。我们取middle，若它满足性质，则满足性质的区间的右边界至少为m,若它不满足性质，则不满足性质的区间的左边界至多为m，满足性质区间的右边界不可能为[m,r]，则可能为[l,m-1]</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">SR</span><span class="hljs-params">(<span class="hljs-type">int</span> * datas, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <br>    <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = n - <span class="hljs-number">1</span>, m = (l + r + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>    <br>    <span class="hljs-keyword">while</span>(l &lt; r) &#123;<br>        <span class="hljs-keyword">if</span>(datas[m] &lt;= x) &#123;<br>            l = m;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            r = m - <span class="hljs-number">1</span>;<br>        &#125;<br>        <br>        m = (l + r + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> l;<br>&#125; <br></code></pre></td></tr></table></figure><p><strong>注意1: 当去获取某个区间的右边界时，middle = (l + r + 1) / 2而</strong></p><p>若middle = (l + r) / 2，则对于数组 2 2，一开始l=0,m=0，而位置0的元素满足性质，则执行语句l=m，这样相当于没操作，接着下一步循环，故会导致死循环。</p><p><strong>注意2: 二分一定有答案。</strong></p><p>无论数列中是否存在解，二分都会返回一个可访问的下标位置，若该下标位置的元素不满足，则数列中不存在解。</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
